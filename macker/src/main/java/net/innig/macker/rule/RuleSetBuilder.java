/*______________________________________________________________________________
 *
 * Macker   http://innig.net/macker/
 *
 * Copyright 2002-2003 Paul Cantrell
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License version 2, as published by the
 * Free Software Foundation. See the file LICENSE.html for more information.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, including the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the license for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc. / 59 Temple
 * Place, Suite 330 / Boston, MA 02111-1307 / USA.
 *______________________________________________________________________________
 */

package net.innig.macker.rule;

import net.innig.io.NullOutputStream;
import net.innig.macker.rule.filter.Filter;
import net.innig.macker.rule.filter.FilterFinder;
import net.innig.sweetxml.ConverterInput;
import net.innig.sweetxml.SweetToXmlConverter;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import org.jdom.Attribute;
import org.jdom.DocType;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;

/**
 * @author Paul Cantrell
 */
public class RuleSetBuilder {

	private SAXBuilder saxBuilder;
	private SAXBuilder saxBuilderVerify;
	private XMLOutputter xmlOut;
	private String dtdUrlS;

	public RuleSetBuilder() {
		this.saxBuilder = new SAXBuilder(false);
		this.saxBuilderVerify = new SAXBuilder(true);
		this.xmlOut = new XMLOutputter();

		// ! hack to get around bogus messages generated by Ant's classloader
		final PrintStream realErr = System.err;
		try {
			System.setErr(new PrintStream(new NullOutputStream()));
			this.dtdUrlS = getClass().getClassLoader().getResource(
					"net/innig/macker/macker.dtd").toExternalForm();
		} finally {
			System.setErr(realErr);
		}
	}

	public Collection<RuleSet> build(final InputStream is)
			throws RulesException {
		try {
			return build(getSaxBuilder().build(is));
		} catch (JDOMException jdome) {
			throw new RulesDocumentException(jdome);
		} catch (IOException ioe) {
			throw new RulesDocumentException(ioe);
		}
	}

	public Collection<RuleSet> build(final Reader reader) throws RulesException {
		try {
			return build(getSaxBuilder().build(reader));
		} catch (JDOMException jdome) {
			throw new RulesDocumentException(jdome);
		} catch (IOException ioe) {
			throw new RulesDocumentException(ioe);
		}
	}

	public Collection<RuleSet> build(final File file) throws RulesException {
		if (file.getName().endsWith(".sxml")) {
			try {
				return build(new SweetToXmlConverter(new ConverterInput(file)));
			} catch (IOException e) {
				throw new RulesDocumentException(e);
			}
		}

		try {
			return build(getSaxBuilder().build(file));
		} catch (JDOMException jdome) {
			throw new RulesDocumentException(jdome);
		} catch (IOException ioe) {
			throw new RulesDocumentException(ioe);
		}
	}

	public Collection<RuleSet> build(final String fileName)
			throws RulesException {
		return build(new File(fileName));
	}

	private Collection<RuleSet> build(final SweetToXmlConverter converter)
			throws RulesException {
		try {
			return build(getSaxBuilder().build(converter.getResultReader()));
		} catch (JDOMException jdome) {
			throw new RulesDocumentException(jdome);
		} catch (IOException ioe) {
			throw new RulesDocumentException(ioe);
		}
	}

	public Collection<RuleSet> build(final Document doc) throws RulesException {
		validateAgainstDTD(doc);
		return build(doc.getRootElement());
	}

	@SuppressWarnings("unchecked")
	public Collection<RuleSet> build(final Element elem) throws RulesException {
		final Collection<RuleSet> ruleSets = new ArrayList<RuleSet>();

		for (Element rsElem : (Collection<Element>) elem.getChildren("ruleset")) {
			ruleSets.add(buildRuleSet(rsElem, RuleSet.getMackerDefaults()));
		}
		return ruleSets;
	}

	private void validateAgainstDTD(final Document doc)
			throws RulesDocumentException {
		doc.setDocType(new DocType("macker", getDtdUrlS()));

		final StringWriter out = new StringWriter();
		try {
			getXmlOut().output(doc, out);
		} catch (IOException ioe) {
			ioe.printStackTrace();
			throw new RuntimeException("Unexpected output exception: " + ioe);
		}
		final Reader in = new StringReader(out.toString());
		try {
			getSaxBuilderVerify().build(in);
		} catch (JDOMException jdome) {
			throw new RulesDocumentException(jdome);
		} catch (IOException ioe) {
			throw new RulesDocumentException(ioe);
		}
	}

	@SuppressWarnings("unchecked")
	public RuleSet buildRuleSet(final Element ruleSetElem, final RuleSet parent)
			throws RulesException {
		final RuleSet ruleSet = new RuleSet(parent);

		final String name = ruleSetElem.getAttributeValue("name");
		if (name != null) {
			ruleSet.setName(name);
		}

		buildSeverity(ruleSet, ruleSetElem);

		for (Element subElem : (Collection<Element>) ruleSetElem.getChildren()) {
			final String subElemName = subElem.getName();
			if ("pattern".equals(subElemName)) {
				final String patternName = subElem.getAttributeValue("name");
				if (ruleSet.declaresPattern(patternName)) {
					throw new RulesDocumentException(subElem,
							"Pattern named \"" + patternName
									+ "\" is already defined in this context");
				}

				ruleSet.setPattern(patternName, buildPattern(subElem, ruleSet));
			} else if ("subset".equals(subElemName)) {
				if (ruleSet.getSubsetPattern() != null) {
					throw new RulesDocumentException(subElem,
							"<ruleset> may only contain a single <subset> element");
				}
				ruleSet.setSubsetPattern(buildPattern(subElem, ruleSet));
			} else if ("access-rule".equals(subElemName)) {
				ruleSet.addRule(buildAccessRule(subElem, ruleSet));
			} else if ("var".equals(subElemName)) {
				ruleSet.addRule(buildVariable(subElem, ruleSet));
			} else if ("foreach".equals(subElemName)) {
				ruleSet.addRule(buildForEach(subElem, ruleSet));
			} else if ("ruleset".equals(subElemName)) {
				ruleSet.addRule(buildRuleSet(subElem, ruleSet));
			} else if ("message".equals(subElemName)) {
				ruleSet.addRule(buildMessage(subElem, ruleSet));
			}
		}

		return ruleSet;
	}

	public Pattern buildPattern(final Element patternElem, final RuleSet ruleSet)
			throws RulesException {
		return buildPattern(patternElem, ruleSet, true, null);
	}

	@SuppressWarnings("unchecked")
	public Pattern buildPattern(final Element patternElem,
			final RuleSet ruleSet, final boolean isTopElem,
			final Pattern nextPat) throws RulesException {
		// handle options

		final String otherPatName = patternElem.getAttributeValue("pattern");
		final String className = getClassNameAttributeValue(patternElem);
		final String filterName = patternElem.getAttributeValue("filter");

		CompositePatternType patType;
		if ("include".equals(patternElem.getName())) {
			patType = CompositePatternType.INCLUDE;
		} else if ("exclude".equals(patternElem.getName())) {
			if (filterName == null) {
				patType = CompositePatternType.EXCLUDE;
			} else {
				patType = CompositePatternType.INCLUDE;
			}
		} else if (isTopElem) {
			patType = CompositePatternType.INCLUDE;
		} else {
			throw new RulesDocumentException(patternElem, "Invalid element <"
					+ patternElem.getName() + "> --"
					+ " expected <include> or <exclude>");
		}

		if (otherPatName != null && className != null) {
			throw new RulesDocumentException(patternElem,
					"patterns cannot have both a \"pattern\" and a \"class\" attribute");
		}

		// do the head thing

		Pattern head = null;
		if (className != null) {
			head = new RegexPattern(className);
		} else if (otherPatName != null) {
			head = ruleSet.getPattern(otherPatName);
			if (head == null) {
				throw new UndeclaredPatternException(otherPatName);
			}
		}

		// build up children

		Pattern childrenPat = null;
		final List<Element> children = new ArrayList<Element>(patternElem.getChildren());
		// !
		// workaround
		// for
		// bug
		// in
		// JUnit
		// List children = patternElem.getChildren(); // this should work
		// instead when JUnit bug is fixed
		for (final ListIterator<Element> childIter = children.listIterator(children
				.size()); childIter.hasPrevious();) {
			final Element subElem = childIter.previous();
			if ("message".equals(subElem.getName())) {
				continue;
			}

			childrenPat = buildPattern(subElem, ruleSet, false, childrenPat);
		}

		// wrap head in a filter if necessary

		if (filterName != null) {
			final Map<String, String> options = new HashMap<String, String>();
			for (Attribute attr : (Collection<Attribute>) patternElem
					.getAttributes()) {
				options.put(attr.getName(), attr.getValue());
			}
			options.remove("name");
			options.remove("pattern");
			options.remove("class");
			options.remove("regex");

			final Filter filter = FilterFinder.findFilter(filterName);
			List<Pattern> params;
			if (head == null) {
				params = new ArrayList<Pattern>();
			} else {
				params = Collections.singletonList(head);
			}
			head = filter.createPattern(ruleSet, params, options);

			if ("exclude".equals(patternElem.getName())) {
				head = CompositePattern.create(CompositePatternType.EXCLUDE,
						head, null, null);
			}
		}

		// pull together composite

		return CompositePattern.create(patType, head, childrenPat, nextPat);
	}

	public Variable buildVariable(final Element forEachElem,
			final RuleSet parent) throws RulesException {
		final String varName = forEachElem.getAttributeValue("name");
		if (varName == null) {
			throw new RulesDocumentException(forEachElem,
					"<var> is missing the \"name\" attribute");
		}

		final String value = forEachElem.getAttributeValue("value");
		if (value == null) {
			throw new RulesDocumentException(forEachElem,
					"<var> is missing the \"value\" attribute");
		}

		return new Variable(parent, varName, value);
	}

	public Message buildMessage(final Element messageElem, final RuleSet parent)
			throws RulesException {
		final Message message = new Message(parent, messageElem.getText());
		buildSeverity(message, messageElem);
		return message;
	}

	public ForEach buildForEach(final Element forEachElem, final RuleSet parent)
			throws RulesException {
		final String varName = forEachElem.getAttributeValue("var");
		if (varName == null) {
			throw new RulesDocumentException(forEachElem,
					"<foreach> is missing the \"var\" attribute");
		}

		final String className = getClassNameAttributeValue(forEachElem);
		if (className == null) {
			throw new RulesDocumentException(forEachElem,
					"<foreach> is missing the \"class\" attribute");
		}

		final ForEach forEach = new ForEach(parent);
		forEach.setVariableName(varName);
		forEach.setRegex(className);
		forEach.setRuleSet(buildRuleSet(forEachElem, parent));
		return forEach;
	}

	@SuppressWarnings("unchecked")
	public AccessRule buildAccessRule(final Element ruleElem,
			final RuleSet ruleSet) throws RulesException {
		AccessRule prevRule = null;
		AccessRule topRule = null;
		for (Element subElem : (List<Element>) ruleElem.getChildren()) {
			final AccessRule accRule = new AccessRule(ruleSet);

			if ("allow".equals(subElem.getName())) {
				accRule.setType(AccessRuleType.ALLOW);
			} else if ("deny".equals(subElem.getName())) {
				accRule.setType(AccessRuleType.DENY);
			} else if ("from".equals(subElem.getName())
					|| "to".equals(subElem.getName())
					|| "message".equals(subElem.getName())) {
				continue;
			} else {
				throw new RulesDocumentException(subElem, "Invalid element <"
						+ subElem.getName() + "> --"
						+ " expected an access rule (<deny> or <allow>)");
			}

			final Element fromElem = subElem.getChild("from");
			if (fromElem != null) {
				accRule.setFrom(buildPattern(fromElem, ruleSet));
			}

			final Element toElem = subElem.getChild("to");
			if (toElem != null) {
				accRule.setTo(buildPattern(toElem, ruleSet));
			}

			if (!subElem.getChildren().isEmpty()) {
				accRule.setChild(buildAccessRule(subElem, ruleSet));
			}

			if (topRule == null) {
				topRule = accRule;
			} else {
				prevRule.setNext(accRule);
			}
			prevRule = accRule;
		}
		if (topRule != null) {
			topRule.setMessage(ruleElem.getChildText("message"));
			buildSeverity(topRule, ruleElem);
		}
		return topRule;
	}

	public void buildSeverity(final Rule rule, final Element elem)
			throws RulesDocumentException {
		final String severityS = elem.getAttributeValue("severity");
		if (severityS != null && !"".equals(severityS)) {
			RuleSeverity severity;
			try {
				severity = RuleSeverity.fromName(severityS);
			} catch (IllegalArgumentException iae) {
				throw new RulesDocumentException(elem, iae.getMessage());
			}
			rule.setSeverity(severity);
		}
	}

	private String getClassNameAttributeValue(final Element elem) {
		String value = elem.getAttributeValue("class");
		if (value == null) {
			value = elem.getAttributeValue("regex");
			if (value != null) {
				System.err.println("WARNING: The \"regex\" attribute is deprecated, and will be removed in v1.0." +
					"  Use \"class\" instead");
			}
		}
		return value;
	}
	
	private String getDtdUrlS() {
		return this.dtdUrlS;
	}
	
	private SAXBuilder getSaxBuilder() {
		return this.saxBuilder;
	}
	
	private SAXBuilder getSaxBuilderVerify() {
		return this.saxBuilderVerify;
	}
	
	private XMLOutputter getXmlOut() {
		return this.xmlOut;
	}
}
