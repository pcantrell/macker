<html>
<head>
<title>Macker Guide: Access Rules</title>
<style>@import "../macker.css";</style>
</head>
<body>

<h1>Macker Guide</h1>

<div class="navbar">
<span class="next">Next:</span> <a href="var-foreach.html">Variables and For Each</a> |
<a href="index.html">Table of Contents</a>
<br>
<a href="../index.html">Home</a> | 
<a href="../faq.html">FAQ</a> |
<a href="http://sourceforge.net/project/showfiles.php?group_id=55296">Download</a> |
<a href="http://sourceforge.net/projects/macker">Sourceforge page</a> |
<a href="../contact.html">Contact</a>
</div>

<h2>Access Rules</h2>
<ul class="pagecontents">
<li> <a href="#allowdeny">Allow / Deny</a>
<li> <a href="#limitations">Limitations</a>
</ul>

<h3><a name="allowdeny">Allow / Deny</a></h3>
<p>
Class <i>A</i> <i>accesses</i> class <i>B</i> if <i>A</i> extends, implements, contains, aggregates, references, or otherwise depends on <i>B</i>.  Macker allows you to allow and deny such accesses between classes by pattern, using the <code>&lt;access-rule&gt;</code> tag.
<p>
The allow/deny construct is very similar to the include/exclude construct, except that it applies to <i>pairs</i> of classes.  An <code>&lt;access-rule&gt;</code> contains <code>&lt;allow&gt;</code> and <code>&lt;deny&gt;</code> rules, each of which may specify a <code>&lt;from&gt;</code> and a <code>&lt;to&gt;</code> pattern:
</p>
<pre>&lt;access-rule&gt;
    &lt;deny&gt;
        &lt;from pattern="ui-layer" /&gt;
        &lt;to pattern="db-layer" /&gt;
    &lt;/deny&gt;
&lt;/access-rule&gt;</pre>
<p>
If you omit a <code>&lt;from&gt;</code> or a <code>&lt;to&gt;</code>, Macker presumes the rule applies from or to anything.  Here, for example, is a rule which forbids any input class from using <code>ThreadGroup</code>:
<pre>&lt;access-rule&gt;
    &lt;deny&gt;
        &lt;to regex="java.lang.ThreadGroup" /&gt;
    &lt;/deny&gt;
&lt;/access-rule&gt;</pre>
<p>
(If you want to see Macker really mad, try putting <code>&lt;deny/&gt;</code> in an access rule!)
<p>
The <code>&lt;from&gt;</code> and <code>&lt;to&gt;</code> tags are secretly anonymous <code>&lt;pattern&gt;</code> tags -- you can nest include/exclude rules inside them.
</p>
<pre>&lt;access-rule&gt;
    &lt;deny&gt;
        &lt;to&gt;
            &lt;include regex="java.lang.ThreadGroup" /&gt;
            &lt;include regex="java.util.Vector" /&gt;
            &lt;include regex="java.util.Hashtable" /&gt;
            &lt;include regex="java.util.Enumeration" /&gt;
        &lt;/to&gt;
    &lt;/deny&gt;
&lt;/access-rule&gt;</pre>
<p>
Nesting allow/deny tags works just as nesting include/exclude does: the inner rules apply only if the outer one did.  One common idiom is to specicfy that only a specific set of classes are allowed to use a certain API or layer by first ruling out everything, then adding back in the privileged classes.  Here, for example, is a rule that says only the DB layer is allowed to access Java's database APIs:
</p>
<pre>&lt;access-rule&gt;
    &lt;deny&gt;
        &lt;to&gt;
            &lt;include regex="java.sql.**" /&gt;
            &lt;include regex="javax.sql.**" /&gt;
            &lt;include regex="javax.jdo.**" /&gt;
        &lt;/to&gt;
        &lt;allow&gt;
            &lt;from pattern="db-layer" /&gt;
        &lt;/allow&gt;
    &lt;/deny&gt;
&lt;/access-rule&gt;</pre>


<h3><a name="limitations">Limitations</a></h3>
<p>
Ideally, Macker's notion of "access" would cover all the kinds of relationships that Java itself would check if <i>B</i> were private and inaccessible to <i>A</i>.  This is almost the case; Macker can detect that class <i>A</i> accesses class <i>B</i> if:
<ul>
<li> <i>A</i> contains a method which takes or returns <i>B</i>,
<li> <i>A</i> contains a field of type <i>B</i>, or
<li> <i>A</i> contains code that would cause the JVM to load class <i>B</i> (which covers any attempt to instantiate, invoke methods on, or typecast to or from <i>B</i>).
</ul>
<p>
There are, however, also some cases which Macker simply cannot check, because the information just isn't there in the bytecode.  The type of a local variable will not show up if it is unused or only assigned to, and nobody invokes any methods on it.  Usage of primitive types is generally difficult to detect (array instantiation and some typecasts do show up).  For obvious reasons, dynamic loading of classes (<code>Class.forName</code> and friends) is beyond Macker's reach.  It is also possible that the compiler will simply optimize away certain kinds of trivial usage of a class.  Unfortunately, as long as Macker operates on compiled classes, there's nothing we can do about any of this.


<div class="next">
Next: <a href="var-foreach.html">Variables and For Each</a>
</div>

<div class="footer">
<div class="navbar">
<span class="next">Next:</span> <a href="var-foreach.html">Variables and For Each</a> |
<a href="index.html">Table of Contents</a>
<br>
<a href="../index.html">Home</a> | 
<a href="../faq.html">FAQ</a> |
<a href="http://sourceforge.net/project/showfiles.php?group_id=55296">Download</a> |
<a href="http://sourceforge.net/projects/macker">Sourceforge page</a> |
<a href="../contact.html">Contact</a>
</div>
</div>
<p align="right">
<A href="http://sourceforge.net"><IMG src="http://sourceforge.net/sflogo.php?group_id=55296" width="88" height="31" border="0" alt="SourceForge Logo"></A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://innig.net/?logo"><img border=0 src="http://innig.net/images/innig_3C0000.gif"></a>

</body>
</html>

